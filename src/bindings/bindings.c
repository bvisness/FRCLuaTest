#include "./md.h"
#include "./md.c"

#define NodeLine(node) MD_CodeLocFromNode(node).line

void printIndent(int level) {
    for (int i = 0; i < level; i++) {
        printf("| ");
    }
}

void DumpNodeR(MD_Node* node, const char* marker, int level) {
    printIndent(level);
    printf("%s %.*s\n", marker, MD_StringExpand(node->string));
    if (!MD_NodeIsNil(node->first_child) || !MD_NodeIsNil(node->first_tag)) {
        printIndent(level);
        printf("|\\\n");
    }

    for (MD_EachNode(n, node->first_tag)) {
        DumpNodeR(n, "@", level + 1);
    }
    for (MD_EachNode(n, node->first_child)) {
        DumpNodeR(n, "*", level + 1);
    }
}

void DumpNode(MD_Node* node) {
    DumpNodeR(node, "*", 0);
}

MD_String8 ParseType(MD_Node* type, MD_Node** next) {
    MD_String8List typePieces = {0};
    MD_PushStringToList(&typePieces, type->string);
    *next = type->next;

    if (MD_StringMatch(type->next->string, MD_S8Lit("*"), 0)) {
        MD_PushStringToList(&typePieces, type->next->string);
        *next = type->next->next;
    }

    return MD_JoinStringList(typePieces, MD_S8Lit(""));
}

int main(int argc, char** argv) {
    MD_ParseResult parse = MD_ParseWholeFile(MD_S8Lit("src/bindings/bindings.metadesk"));
    
    if (parse.first_error) {
        for (MD_Error *error = parse.first_error; error != 0; error = error->next) {
            MD_CodeLoc loc = MD_CodeLocFromNode(error->node);
            printf("ERROR (line %d, column %d): %.*s\n", loc.line, loc.column, MD_StringExpand(error->string));
        }
        return 1;
    }
    
    DumpNode(parse.node);

    for (MD_EachNode(f, parse.node->first_child)) {
        fprintf(stderr, "Processing file \"%.*s\"...\n", MD_StringExpand(f->string));

        char filename_buf[128];
        sprintf(filename_buf, "src/main/cpp/wpilib/%.*s.cpp", MD_StringExpand(f->string));
        FILE* cppfile = fopen(filename_buf, "w");

        MD_String8List ffiDefs = {0};

        fprintf(cppfile, "// Automatically generated by bindings.c. DO NOT EDIT.\n\n");

        for (MD_EachNode(tag, f->first_tag)) {
            if (MD_StringMatch(tag->string, MD_S8Lit("include"), 0)) {
                fprintf(cppfile, "#include %.*s\n", MD_StringExpand(tag->first_child->string));
            } else {
                fclose(cppfile);
                fprintf(stderr, "ERROR (line %d): Unrecognized tag on file: %.*s\n", NodeLine(tag), MD_StringExpand(tag->string));                return 1;
            }
        }
        fprintf(cppfile, "\n");

        fprintf(cppfile, "#include \"luadef.h\"\n\n");

        for (MD_EachNode(fentry, f->first_child)) {
            if (MD_NodeHasTag(fentry, MD_S8Lit("raw_func"))) {
                fprintf(stderr, ".");
                MD_String8 signature = fentry->string;
                MD_String8 body = fentry->first_child->string;
                fprintf(cppfile, "LUAFUNC %.*s {%.*s}\n\n", MD_StringExpand(signature), MD_StringExpand(body));
                MD_PushStringToList(&ffiDefs, MD_PushStringF("%.*s;", MD_StringExpand(signature)));
            } else if (MD_NodeHasTag(fentry, MD_S8Lit("class"))) {
                MD_String8 className = fentry->string;
                MD_String8 cppClass;
                for (MD_EachNode(tag, fentry->first_tag)) {
                    if (MD_StringMatch(tag->string, MD_S8Lit("class"), 0)) {
                        cppClass = tag->first_child->string;
                    } else {
                        fclose(cppfile);
                        fprintf(stderr, "ERROR (line %d): Unrecognized tag on class: %.*s\n", NodeLine(tag), MD_StringExpand(tag->string));
                        return 1;
                    }
                }

                MD_Node* funcNode = fentry->first_child;
                while (1) {
                    if (MD_NodeIsNil(funcNode)) {
                        break;
                    }

                    fprintf(stderr, ".");

                    MD_String8 returnType;
                    MD_String8 funcName;

                    MD_Node* argsNode;
                    MD_String8 customBody;

                    MD_Node* nextFuncNode;

                    if (MD_NodeHasTag(funcNode, MD_S8Lit("constructor"))) {
                        // Constructors have no defined return type (the C++ code always
                        // returns void*) and no possibility for a custom function body.

                        returnType = MD_S8Lit("void*");
                        funcName = funcNode->string;
                        argsNode = funcNode->next;
                        nextFuncNode = argsNode->next;
                    } else {
                        MD_Node* afterType;
                        returnType = ParseType(funcNode, &afterType);
                        funcName = afterType->string;
                        argsNode = afterType->next;
                        nextFuncNode = argsNode->next;

                        if (MD_NodeHasTag(funcNode, MD_S8Lit("custom"))) {
                            customBody = argsNode->next->string;
                            nextFuncNode = argsNode->next->next;
                        }
                    }

                    int numArgs = 0;
                    MD_String8 argTypes[16] = {0};
                    MD_String8 argNames[16] = {0};
                    MD_String8 argCasts[16] = {0};

                    MD_Node* arg = argsNode->first_child;
                    while (1) {
                        if (MD_NodeIsNil(arg)) {
                            break;
                        }

                        for (MD_EachNode(tag, arg->first_tag)) {
                            if (MD_StringMatch(tag->string, MD_S8Lit("cast"), 0)) {
                                argCasts[numArgs] = tag->first_child->string;
                            } else {
                                fclose(cppfile);
                                fprintf(stderr, "ERROR (line %d): Unrecognized tag for function argument: %.*s\n", NodeLine(tag), MD_StringExpand(tag->string));
                                return 1;
                            }
                        }

                        MD_Node* afterType;
                        argTypes[numArgs] = ParseType(arg, &afterType);
                        argNames[numArgs] = afterType->string;
                        numArgs++;

                        arg = afterType->next;
                    }

                    MD_String8 signature = MD_PushStringF("%.*s %.*s_%.*s", MD_StringExpand(returnType), MD_StringExpand(className), MD_StringExpand(funcName));

                    fprintf(cppfile, "LUAFUNC %.*s(", MD_StringExpand(signature));
                    for (int i = 0; i < numArgs; i++) {
                        if (i > 0) {
                            fprintf(cppfile, ", ");
                        }
                        fprintf(cppfile, "%.*s %.*s", MD_StringExpand(argTypes[i]), MD_StringExpand(argNames[i]));
                    }
                    fprintf(cppfile, ") {\n");
                    fprintf(cppfile, "}\n\n");

                    MD_PushStringToList(&ffiDefs, MD_PushStringF("%.*s;", MD_StringExpand(signature)));

                    funcNode = nextFuncNode;
                }
            } else {
                fclose(cppfile);
                fprintf(stderr, "ERROR (line %d): Unrecognized entry type\n", NodeLine(fentry));
                return 1;
            }
        }

        fprintf(stderr, "\n");
        fclose(cppfile);
    }

    return 0;
}
